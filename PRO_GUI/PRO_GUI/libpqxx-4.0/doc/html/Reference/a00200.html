<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libpqxx: Prepared statements</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpqxx&#160;<span id="projectnumber">4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00200.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Prepared statements</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
</table>
<p>Prepared statements are SQL queries that you define once and then invoke as many times as you like, typically with varying parameters. It's basically a function that you can define ad hoc.</p>
<p>If you have an SQL statement that you're going to execute many times in quick succession, it may be more efficient to prepare it once and reuse it. This saves the database backend the effort of parsing complex SQL and figuring out an efficient execution plan. Another nice side effect is that you don't need to worry about escaping parameters.</p>
<p>You create a prepared statement by preparing it on the connection, passing an identifier and its SQL text. The identifier is the name by which the prepared statement will be known; it should consist of letters, digits, and underscores only and start with a letter. The name is case-sensitive.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> prepare_my_statement(<a class="code" href="a00023.html" title="connection_base abstract base class; represents a connection to a database.">pqxx::connection_base</a> &amp;c)
 {
   c.<a class="code" href="a00023.html#ab71d463277c017f695eed71cdd87afb2" title="Define a prepared statement.">prepare</a>(<span class="stringliteral">&quot;my_statement&quot;</span>, <span class="stringliteral">&quot;SELECT * FROM Employee WHERE name = &#39;Xavier&#39;&quot;</span>);
 }
</pre></div><p>Once you've done this, you'll be able to call <code>my_statement</code> from any transaction you execute on the same connection. Note that this uses a member function called <code>"prepared"</code>; the definition used a member function called <code>"prepare"</code>.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="a00082.html" title="Result set containing data returned by a query or command.">pqxx::result</a> execute_my_statement(<a class="code" href="a00104.html">pqxx::transaction_base</a> &amp;t)
 {
   <span class="keywordflow">return</span> t.<a class="code" href="a00104.html#a1357ac4f6330284129c91882a169276d" title="Execute prepared statement.">prepared</a>(<span class="stringliteral">&quot;my_statement&quot;</span>).exec();
 }
</pre></div><p>Did I mention that you can pass parameters to prepared statements? You define those along with the statement. The query text uses $<code>1</code>, <code>$2</code> etc. as placeholders for the parameters in the SQL text. Since your C++ compiler doesn't know how many parameters you're going to define, the syntax that lets you do this is a bit strange:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> prepare_find(<a class="code" href="a00023.html" title="connection_base abstract base class; represents a connection to a database.">pqxx::connection_base</a> &amp;c)
 {
   <span class="comment">// Prepare a statement called &quot;find&quot; that looks for employees with a given</span>
   <span class="comment">// name (parameter 1) whose salary exceeds a given number (parameter 2).</span>
   <span class="keyword">const</span> std::string sql =
     <span class="stringliteral">&quot;SELECT * FROM Employee WHERE name = $1 AND salary &gt; $2&quot;</span>;
 
   c.<a class="code" href="a00023.html#ab71d463277c017f695eed71cdd87afb2" title="Define a prepared statement.">prepare</a>(<span class="stringliteral">&quot;find&quot;</span>, sql)()();
 }
</pre></div><p>It's the <code></code>()() that declares the two parameters. If any of the parameters will be in binary form, you will pass treat_binary in the corresponding pair of parentheses.</p>
<p>When invoking the prepared statement, you pass parameter values using a similar syntax.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="a00082.html" title="Result set containing data returned by a query or command.">pqxx::result</a> execute_find(
   <a class="code" href="a00104.html">pqxx::transaction_base</a> &amp;t, std::string name, <span class="keywordtype">int</span> min_salary)
 {
   <span class="keywordflow">return</span> t.<a class="code" href="a00104.html#a1357ac4f6330284129c91882a169276d" title="Execute prepared statement.">prepared</a>(<span class="stringliteral">&quot;find&quot;</span>)(name)(min_salary).exec();
 }
</pre></div><dl class="warning"><dt><b>Warning:</b></dt><dd>There are cases where prepared statements are actually slower than plain SQL. Sometimes the backend can produce a better execution plan when it knows the parameter values. For example, say you've got a web application and you're querying for users with status "inactive" who have email addresses in a given domain name X. If X is a very popular provider, the best way to plan the query may be to list the inactive users first and then filter for the email addresses you're looking for. But in other cases, it may be much faster to find matching email addresses first and then see which of their owners are "inactive." A prepared statement must be planned to fit either case, but a direct query can be optimized based on table statistics, partial indexes, etc. </dd></dl>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Sun Nov 27 2011 18:14:12 for libpqxx by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
