<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libpqxx: pqxx::pipeline Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpqxx&#160;<span id="projectnumber">4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00068.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">pqxx::pipeline Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="pqxx::pipeline" --><!-- doxytag: inherits="pqxx::internal::transactionfocus" -->
<p>Processes several queries in FIFO manner, optimized for high throughput.  
 <a href="a00068.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00152_source.html">pipeline.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pqxx::pipeline:</div>
<div class="dyncontent">
<div class="center"><img src="a00340.png" border="0" usemap="#pqxx_1_1pipeline_inherit__map" alt="Inheritance graph"/></div>
<map name="pqxx_1_1pipeline_inherit__map" id="pqxx_1_1pipeline_inherit__map">
<area shape="rect" id="node2" href="a00105.html" title="pqxx::internal::transactionfocus" alt="" coords="5,83,208,112"/><area shape="rect" id="node4" href="a00059.html" title="pqxx::internal::namedclass" alt="" coords="17,5,196,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00341.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>getquery</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Query</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">query_id</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a41ad44c7f13ad198db938c84e25473a9">pipeline</a> (<a class="el" href="a00104.html">transaction_base</a> &amp;, const std::string &amp;Name=std::string())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#ab265dd1ed168022f92a207dd62bad5d1">~pipeline</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a839abbb0e60ac35e941a632027b4f917">insert</a> (const std::string &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add query to the pipeline.  <a href="#a839abbb0e60ac35e941a632027b4f917"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a7808218284e98bb5dffaf110defd1b33">complete</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all ongoing or pending operations to complete.  <a href="#a7808218284e98bb5dffaf110defd1b33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a33a890c64efc37d76f3c649f145ff950">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget all ongoing or pending operations and retrieved results.  <a href="#a33a890c64efc37d76f3c649f145ff950"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#ab375b0b4e02c7f1a48602c4186fbbbd7">cancel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel ongoing query, if any.  <a href="#ab375b0b4e02c7f1a48602c4186fbbbd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a3d89c57d7619430a3847595d8fb902bc">is_finished</a> (<a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is result for given query available?  <a href="#a3d89c57d7619430a3847595d8fb902bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00082.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a19c508710d0025993e41512f23de56be">retrieve</a> (<a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">query_id</a> qid)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve result for given query.  <a href="#a19c508710d0025993e41512f23de56be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>, <a class="el" href="a00082.html">result</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a9edc9c6e50f25790c3707495ab9779dd">retrieve</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve oldest unretrieved result (possibly wait for one)  <a href="#a9edc9c6e50f25790c3707495ab9779dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a5f5fe658349dcd9aed9c19faccf23ea4">empty</a> () const   throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#af94a53d0eecb7485cb135155f912ce8e">retain</a> (int retain_max=2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of queries to retain before issuing them to the backend.  <a href="#af94a53d0eecb7485cb135155f912ce8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html#a153e247a4f449ce8069379c4567738e9">resume</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume retained query emission (harmless when not needed)  <a href="#a153e247a4f449ce8069379c4567738e9"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Processes several queries in FIFO manner, optimized for high throughput. </p>
<p>Use a pipeline if you want to execute queries without always sitting still while they execute. Result retrieval is decoupled from execution request; queries "go in at the front" and results "come out the back." Actually results may be retrieved in any order, if you want.</p>
<p>Feel free to pump as many queries into the pipeline as possible, even if they were generated after looking at a result from the same pipeline. To get the best possible throughput, try to make insertion of queries run as far ahead of results retrieval as possible; issue each query as early as possible and retrieve their results as late as possible, so the pipeline has as many ongoing queries as possible at any given time. In other words, keep it busy!</p>
<p>One warning: if any of the queries you insert leads to a syntactic error, the error may be returned as if it were generated by an older query. Future versions may try to work around this if working in a nontransaction. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ab53d0c0294ef3c3c7147be2ab55bab0e"></a><!-- doxytag: member="pqxx::pipeline::query_id" ref="ab53d0c0294ef3c3c7147be2ab55bab0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">pqxx::pipeline::query_id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a41ad44c7f13ad198db938c84e25473a9"></a><!-- doxytag: member="pqxx::pipeline::pipeline" ref="a41ad44c7f13ad198db938c84e25473a9" args="(transaction_base &amp;, const std::string &amp;Name=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pqxx::pipeline::pipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00104.html">transaction_base</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Name</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab265dd1ed168022f92a207dd62bad5d1"></a><!-- doxytag: member="pqxx::pipeline::~pipeline" ref="ab265dd1ed168022f92a207dd62bad5d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pqxx::pipeline::~pipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab375b0b4e02c7f1a48602c4186fbbbd7"></a><!-- doxytag: member="pqxx::pipeline::cancel" ref="ab375b0b4e02c7f1a48602c4186fbbbd7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel ongoing query, if any. </p>
<p>May cancel any or all of the queries that have been inserted at this point whose results have not yet been retrieved. If the pipeline lives in a backend transaction, that transaction may be left in a nonfunctional state in which it can only be aborted.</p>
<p>Therefore, either use this function in a nontransaction, or abort the transaction after calling it. </p>

</div>
</div>
<a class="anchor" id="a7808218284e98bb5dffaf110defd1b33"></a><!-- doxytag: member="pqxx::pipeline::complete" ref="a7808218284e98bb5dffaf110defd1b33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::complete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for all ongoing or pending operations to complete. </p>
<p>Detaches from the transaction when done. </p>

</div>
</div>
<a class="anchor" id="a5f5fe658349dcd9aed9c19faccf23ea4"></a><!-- doxytag: member="pqxx::pipeline::empty" ref="a5f5fe658349dcd9aed9c19faccf23ea4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::pipeline::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a33a890c64efc37d76f3c649f145ff950"></a><!-- doxytag: member="pqxx::pipeline::flush" ref="a33a890c64efc37d76f3c649f145ff950" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forget all ongoing or pending operations and retrieved results. </p>
<p>Queries already sent to the backend may still be completed, depending on implementation and timing.</p>
<p>Any error state (unless caused by an internal error) will also be cleared. This is mostly useful in a nontransaction, since a backend transaction is aborted automatically when an error occurs.</p>
<p>Detaches from the transaction when done. </p>

</div>
</div>
<a class="anchor" id="a839abbb0e60ac35e941a632027b4f917"></a><!-- doxytag: member="pqxx::pipeline::insert" ref="a839abbb0e60ac35e941a632027b4f917" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">pipeline::query_id</a> pqxx::pipeline::insert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add query to the pipeline. </p>
<p>Queries are accumulated in the pipeline and sent to the backend in a concatenated format, separated by semicolons. The queries you insert must not use this construct themselves, or the pipeline will get hopelessly confused! </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Identifier for this query, unique only within this pipeline </dd></dl>

</div>
</div>
<a class="anchor" id="a3d89c57d7619430a3847595d8fb902bc"></a><!-- doxytag: member="pqxx::pipeline::is_finished" ref="a3d89c57d7619430a3847595d8fb902bc" args="(query_id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::pipeline::is_finished </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">pipeline::query_id</a>&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is result for given query available? </p>

<p>References <a class="el" href="a00176.html#a35be8b6c29c0272a015f356089c1d2ed">pqxx::to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a153e247a4f449ce8069379c4567738e9"></a><!-- doxytag: member="pqxx::pipeline::resume" ref="a153e247a4f449ce8069379c4567738e9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::pipeline::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resume retained query emission (harmless when not needed) </p>

</div>
</div>
<a class="anchor" id="af94a53d0eecb7485cb135155f912ce8e"></a><!-- doxytag: member="pqxx::pipeline::retain" ref="af94a53d0eecb7485cb135155f912ce8e" args="(int retain_max=2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::pipeline::retain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>retain_max</em> = <code>2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set maximum number of queries to retain before issuing them to the backend. </p>
<p>The pipeline will perform better if multiple queries are issued at once, but retaining queries until the results are needed (as opposed to issuing them to the backend immediately) may negate any performance benefits the pipeline can offer.</p>
<p>Recommended practice is to set this value no higher than the number of queries you intend to insert at a time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">retain_max</td><td>A nonnegative "retention capacity;" passing zero will cause queries to be issued immediately </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Old retention capacity </dd></dl>

<p>References <a class="el" href="a00176.html#a35be8b6c29c0272a015f356089c1d2ed">pqxx::to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a19c508710d0025993e41512f23de56be"></a><!-- doxytag: member="pqxx::pipeline::retrieve" ref="a19c508710d0025993e41512f23de56be" args="(query_id qid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00082.html">result</a> pqxx::pipeline::retrieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">query_id</a>&#160;</td>
          <td class="paramname"><em>qid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve result for given query. </p>
<p>If the query failed for whatever reason, this will throw an exception. The function will block if the query has not finished yet. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If results are retrieved out-of-order, i.e. in a different order than the one in which their queries were inserted, errors may "propagate" to subsequent queries. </dd></dl>

<p>References <a class="el" href="a00068.html#a19c508710d0025993e41512f23de56be">retrieve()</a>.</p>

<p>Referenced by <a class="el" href="a00068.html#a19c508710d0025993e41512f23de56be">retrieve()</a>.</p>

</div>
</div>
<a class="anchor" id="a9edc9c6e50f25790c3707495ab9779dd"></a><!-- doxytag: member="pqxx::pipeline::retrieve" ref="a9edc9c6e50f25790c3707495ab9779dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="a00068.html#ab53d0c0294ef3c3c7147be2ab55bab0e">pipeline::query_id</a>, <a class="el" href="a00082.html">result</a> &gt; pqxx::pipeline::retrieve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve oldest unretrieved result (possibly wait for one) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The query's identifier and its result set </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00152_source.html">pipeline.hxx</a></li>
<li>pipeline.cxx</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00176.html">pqxx</a>      </li>
      <li class="navelem"><a class="el" href="a00068.html">pipeline</a>      </li>
      <li class="footer">Generated on Sun Nov 27 2011 18:14:13 for libpqxx by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
