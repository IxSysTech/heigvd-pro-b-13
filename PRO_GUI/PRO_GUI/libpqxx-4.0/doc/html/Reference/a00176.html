<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libpqxx: pqxx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpqxx&#160;<span id="projectnumber">4.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00176.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pqxx Namespace Reference</div>  </div>
</div>
<div class="contents">

<p>The home of all libpqxx classes, functions, templates, etc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">internal</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Private namespace for libpqxx's internal use; do not access. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">prepare</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Dedicated namespace for helper types related to prepared statements. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">basic_connection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The ultimate template that defines a connection type.  <a href="a00006.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">binarystring</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">connect_direct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection policy; creates an immediate connection to a database.  <a href="a00020.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">connect_lazy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy connection policy; causes connection to be deferred until first use.  <a href="a00021.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">connect_async</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous connection policy; connects "in the background".  <a href="a00019.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">connect_null</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonfunctional, always-down connection policy for testing/debugging purposes.  <a href="a00022.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">connection_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00023.html" title="connection_base abstract base class; represents a connection to a database.">connection_base</a> abstract base class; represents a connection to a database.  <a href="a00023.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">connectionpolicy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">cursor_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Common definitions for cursor types.  <a href="a00030.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">stateless_cursor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Stateless cursor" class: easy API for retrieving parts of result sets  <a href="a00087.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">icursorstream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple read-only cursor represented as a stream of results.  <a href="a00044.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">icursor_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate istream_iterator for icursorstream.  <a href="a00043.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">dbtransaction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">errorhandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for error-handler callbacks.  <a href="a00036.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">quiet_errorhandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler that suppresses any previously registered error handlers.  <a href="a00076.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">pqxx_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin base class to identify libpqxx-specific exception types.  <a href="a00074.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">failure</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run-time failure encountered by libpqxx, similar to std::runtime_error.  <a href="a00038.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">broken_connection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for lost or failed backend connection.  <a href="a00014.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">sql_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for failed queries.  <a href="a00086.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">in_doubt_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Help, I don't know whether transaction was committed successfully!"  <a href="a00045.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">internal_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal error in libpqxx library.  <a href="a00049.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">usage_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Error in usage of libpqxx library, similar to std::logic_error.  <a href="a00113.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">argument_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid argument passed to libpqxx, similar to std::invalid_argument.  <a href="a00004.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">conversion_error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">range_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Something is out of range, similar to std::out_of_range.  <a href="a00077.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">feature_not_supported</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Database feature not supported in current setup.  <a href="a00039.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">data_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Error in data provided to SQL statement.  <a href="a00031.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">integrity_constraint_violation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">restrict_violation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">not_null_violation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">foreign_key_violation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">unique_violation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">check_violation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">invalid_cursor_state</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">invalid_sql_statement_name</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">invalid_cursor_name</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">syntax_error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">undefined_column</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">undefined_function</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">undefined_table</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">insufficient_privilege</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">insufficient_resources</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource shortage on the server.  <a href="a00047.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">disk_full</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">out_of_memory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">too_many_connections</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">plpgsql_error</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PL/pgSQL error.  <a href="a00069.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">plpgsql_raise</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception raised in PL/pgSQL procedure.  <a href="a00071.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">plpgsql_no_data_found</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">plpgsql_too_many_rows</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">field</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a field in a result set.  <a href="a00040.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">field_streambuf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">basic_fieldstream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream that gets its data from a result field.  <a href="a00007.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">isolation_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class to describe an isolation level; primarly for libpqxx's own use.  <a href="a00054.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">largeobject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity of a large object.  <a href="a00056.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">largeobjectaccess</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for large object's contents.  <a href="a00058.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">largeobject_streambuf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Streambuf to use large objects in standard I/O streams.  <a href="a00057.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">basic_ilostream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream that gets its data from a large object.  <a href="a00008.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">basic_olostream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream that writes data back to a large object.  <a href="a00010.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">basic_lostream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream that reads and writes a large object.  <a href="a00009.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">nontransaction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">notification_receiver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">notify_listener</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obsolete notification receiver.  <a href="a00063.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">pipeline</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes several queries in FIFO manner, optimized for high throughput.  <a href="a00068.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Result set containing data returned by a query or command.  <a href="a00082.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">const_result_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for rows (tuples) in a result. Use as <a class="el" href="a00082.html#a231cf3451b578e1a77a0e3ba5c5332c0">result::const_iterator</a>.  <a href="a00025.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">const_reverse_result_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator for result. Use as <a class="el" href="a00082.html#a4e8a0b23393257bb8438323af622ab0b">result::const_reverse_iterator</a>.  <a href="a00026.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">basic_robusttransaction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">robusttransaction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Slightly slower, better-fortified version of transaction.  <a href="a00083.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">string_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for use in string conversions.  <a href="a00088.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">string_traits&lt; const char * &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String traits for C-style string ("pointer to const char")  <a href="a00091.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">string_traits&lt; char * &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String traits for non-const C-style string ("pointer to char")  <a href="a00089.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">string_traits&lt; char[N]&gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String traits for C-style string constant ("array of char")  <a href="a00090.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">string_traits&lt; const char[N]&gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String traits for "array of const char.".  <a href="a00092.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">string_traits&lt; std::string &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">string_traits&lt; const std::string &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">string_traits&lt; std::stringstream &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">subtransaction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Transaction" nested within another transaction  <a href="a00096.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">tablereader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">tablestream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">tablewriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">basic_transaction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">transaction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard back-end transaction, templatized on isolation level.  <a href="a00103.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">transaction_base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">transactor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">tuple</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to one row in a result.  <a href="a00107.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">const_tuple_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for fields in a tuple. Use as <a class="el" href="a00107.html#abb8219326beee6e2d04cdc186c948b28">tuple::const_iterator</a>.  <a href="a00028.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">const_reverse_tuple_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator for a tuple. Use as <a class="el" href="a00107.html#a00b39ba19194ab4ed39a66db5d706bdf">tuple::const_reverse_iterator</a>.  <a href="a00027.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">thread_safety_model</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor of library's thread-safety model.  <a href="a00101.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">items</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of items with easy contents initialization and string rendering.  <a href="a00055.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00006.html">basic_connection</a><br class="typebreak"/>
&lt; <a class="el" href="a00020.html">connect_direct</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#ga26edb910e4563d1115e22c627914e98b">connection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The "standard" connection type: connect to database right now.  <a href="a00204.html#ga26edb910e4563d1115e22c627914e98b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00006.html">basic_connection</a><br class="typebreak"/>
&lt; <a class="el" href="a00021.html">connect_lazy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#ga8911912522c75dd0b154fefdde735272">lazyconnection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A "lazy" connection type: connect to database only when needed.  <a href="a00204.html#ga8911912522c75dd0b154fefdde735272"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00006.html">basic_connection</a><br class="typebreak"/>
&lt; <a class="el" href="a00019.html">connect_async</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#ga710db2d58482a4ea8ebbb822c2b0d417">asyncconnection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Asynchronous" connection type: start connecting, but don't wait for it  <a href="a00204.html#ga710db2d58482a4ea8ebbb822c2b0d417"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00006.html">basic_connection</a><br class="typebreak"/>
&lt; <a class="el" href="a00022.html">connect_null</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#ga830f18f804ec3e4cc8bab713169fb529">nullconnection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A "dummy" connection type: don't connect to any database at all.  <a href="a00204.html#ga830f18f804ec3e4cc8bab713169fb529"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#ac6f886167ad26ee519591f7a983ac6d9">tuple_size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#afb3789542d30cda25ee02ba8d2c41a46">tuple_difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00007.html">basic_fieldstream</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a82a9c2e4bb780869117bbe794ea24616">fieldstream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00008.html">basic_ilostream</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#ad07694cd816b68c7fc920a616daa8771">ilostream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00010.html">basic_olostream</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a9a79c907a65843b9d4887ccbb44d5b1b">olostream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00009.html">basic_lostream</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a368340378e939373681ad2e39781fc8b">lostream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html">transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html#ga82685329d6fd91f5ab30772d266fe5f0">work</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bog-standard, default transaction type.  <a href="a00205.html#ga82685329d6fd91f5ab30772d266fe5f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00103.html">transaction</a><br class="typebreak"/>
&lt; read_committed, read_only &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html#gab81d0f16865bb70a79d4acb0d0657259">read_transaction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only transaction.  <a href="a00205.html#gab81d0f16865bb70a79d4acb0d0657259"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00063.html">notify_listener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a6808f9a0c8dea288c2df81b930d06c34">trigger</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a1dc4688a8f01e6679b2afa93481836cc">readwrite_policy</a> { <a class="el" href="a00176.html#a1dc4688a8f01e6679b2afa93481836cca4080e8f00464997c4345ddb2a15b3986">read_only</a>, 
<a class="el" href="a00176.html#a1dc4688a8f01e6679b2afa93481836cca7fbb98c4665801b02d8cbeeb2dde0858">read_write</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a8f05a60f9e1f7dc4e4af5dce6b987c8c">isolation_level</a> { <a class="el" href="a00176.html#a8f05a60f9e1f7dc4e4af5dce6b987c8cabedeb7c33721ac28a9e35be36f214f2d">read_committed</a>, 
<a class="el" href="a00176.html#a8f05a60f9e1f7dc4e4af5dce6b987c8ca022ad2c1a5b247f6cc5790909e708569">serializable</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transaction isolation levels; PostgreSQL doesn't implement all SQL levels.  <a href="a00176.html#a8f05a60f9e1f7dc4e4af5dce6b987c8c">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html#ga5a9191cb199f2b67350de847e468e38b">escape_binary</a> (const std::string &amp;bin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape binary string for inclusion in SQL.  <a href="a00203.html#ga5a9191cb199f2b67350de847e468e38b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html#gad40c643f4f483941c07c7f25d9091abc">escape_binary</a> (const char bin[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape binary string for inclusion in SQL.  <a href="a00203.html#gad40c643f4f483941c07c7f25d9091abc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html#ga67d0543fc753d81b490cb7c77205a283">escape_binary</a> (const char bin[], size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape binary string for inclusion in SQL.  <a href="a00203.html#ga67d0543fc753d81b490cb7c77205a283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html#gad1faeced6ee13b17fbc3aca21712cc7c">escape_binary</a> (const unsigned char bin[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape binary string for inclusion in SQL.  <a href="a00203.html#gad1faeced6ee13b17fbc3aca21712cc7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html#ga80a4bfe9b1c1b88c29d16ba06102370b">escape_binary</a> (const unsigned char bin[], size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape binary string for inclusion in SQL.  <a href="a00203.html#ga80a4bfe9b1c1b88c29d16ba06102370b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#aad07bde6f6d1012bc1fbd66e2339a213">encrypt_password</a> (const std::string &amp;user, const std::string &amp;password)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt password for given user. Requires libpq 8.2 or better.  <a href="#aad07bde6f6d1012bc1fbd66e2339a213"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00176.html#ac634c894064d879d8e563175842e27be">field::to&lt; std::string &gt;</a> (std::string &amp;Obj) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization: <code>to(string &amp;)</code>.  <a href="#ac634c894064d879d8e563175842e27be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CHAR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00176.html#a8ce373522ba1facb44d6facb66667e5a">operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR &gt; &amp;S, const <a class="el" href="a00040.html">pqxx::field</a> &amp;F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a result field to any type of stream.  <a href="#a8ce373522ba1facb44d6facb66667e5a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00176.html#aab2b52ca97031dff1e8a6a7f654c04ea">from_string</a> (const <a class="el" href="a00040.html">field</a> &amp;F, T &amp;Obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a field's string contents to another type.  <a href="#aab2b52ca97031dff1e8a6a7f654c04ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00176.html#a35be8b6c29c0272a015f356089c1d2ed">to_string</a> (const <a class="el" href="a00040.html">field</a> &amp;Obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a field to a string.  <a href="#a35be8b6c29c0272a015f356089c1d2ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00025.html">const_result_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a14f86142785f212ef3de46040e22c532">operator+</a> (<a class="el" href="a00082.html#abec7f7f4d7ed030f38b2a123b632b818">result::difference_type</a> o, <a class="el" href="a00025.html">const_result_iterator</a> i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00026.html">const_reverse_result_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#af9d548cd3c597e67d8a4288ba24a17f8">operator+</a> (<a class="el" href="a00082.html#abec7f7f4d7ed030f38b2a123b632b818">result::difference_type</a> n, const <a class="el" href="a00026.html">const_reverse_result_iterator</a> &amp;i)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gad1cc702bf191d535e40a2d5b84042e1c">from_string</a> (const char Str[], T &amp;Obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to convert postgres-generated string to given built-in type.  <a href="a00201.html#gad1cc702bf191d535e40a2d5b84042e1c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gacd9090fef37cdca192a4e8204ef895c4">from_string</a> (const char Str[], T &amp;Obj, size_t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion with known string length (for strings that may contain nuls)  <a href="a00201.html#gacd9090fef37cdca192a4e8204ef895c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gaf11e0dd40ce4ff2094cc37337a972eed">from_string&lt; std::string &gt;</a> (const char Str[], std::string &amp;Obj, size_t len)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gadadff252c93dc630108f1667a75342b7">from_string</a> (const std::string &amp;Str, T &amp;Obj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ga5c1f04f36ada2b9ef338fc9d91fd4d4b">from_string</a> (const std::stringstream &amp;Str, T &amp;Obj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gadf364687d64294fccdb7229fbcd4e871">from_string</a> (const std::string &amp;Str, std::string &amp;Obj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ga73d2bdd0531ce4f30db5ff11b4a8eaed">to_string</a> (const T &amp;Obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert built-in type to a readable string that PostgreSQL will understand.  <a href="a00201.html#ga73d2bdd0531ce4f30db5ff11b4a8eaed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00028.html">const_tuple_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a79ecc564993aea182fe2d82ea9512e91">operator+</a> (<a class="el" href="a00028.html#adf1e8d933ff2f633c68a10261bdec228">const_tuple_iterator::difference_type</a> o, <a class="el" href="a00028.html">const_tuple_iterator</a> i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00101.html">thread_safety_model</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#aac7c904372c0bffcd8c8b121f2c3f13e">describe_thread_safety</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe thread safety available in this build.  <a href="#aac7c904372c0bffcd8c8b121f2c3f13e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ITER , typename ACCESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00176.html#a99697c7c2e72286fc59e48c8af803c18">separated_list</a> (const std::string &amp;sep, ITER begin, ITER end, ACCESS access)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access iterators using ACCESS functor, returning separator-separated list.  <a href="#a99697c7c2e72286fc59e48c8af803c18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#ga76574bffb7a200dc73a88bf1be8903d8">separated_list</a> (const std::string &amp;sep, ITER begin, ITER end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Render sequence as a string, using given separator between items.  <a href="a00202.html#ga76574bffb7a200dc73a88bf1be8903d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OBJ &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#ga906e10386166c6e50c431ccdd4d46398">separated_list</a> (const std::string &amp;sep, OBJ *begin, OBJ *end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Render array as a string, using given separator between items.  <a href="a00202.html#ga906e10386166c6e50c431ccdd4d46398"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gad27bc0a5b6af481377eec61bc7da597f">separated_list</a> (const std::string &amp;sep, const CONTAINER &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Render items in a container as a string, using given separator.  <a href="a00202.html#gad27bc0a5b6af481377eec61bc7da597f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const oid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html#a1abfa7aae5089dad48d69a60a9e557e3">oid_none</a> = 0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The "null" oid.  <a href="#a1abfa7aae5089dad48d69a60a9e557e3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The home of all libpqxx classes, functions, templates, etc. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a82a9c2e4bb780869117bbe794ea24616"></a><!-- doxytag: member="pqxx::fieldstream" ref="a82a9c2e4bb780869117bbe794ea24616" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00007.html">basic_fieldstream</a>&lt;char&gt; <a class="el" href="a00007.html">pqxx::fieldstream</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad07694cd816b68c7fc920a616daa8771"></a><!-- doxytag: member="pqxx::ilostream" ref="ad07694cd816b68c7fc920a616daa8771" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00008.html">basic_ilostream</a>&lt;char&gt; <a class="el" href="a00008.html">pqxx::ilostream</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a368340378e939373681ad2e39781fc8b"></a><!-- doxytag: member="pqxx::lostream" ref="a368340378e939373681ad2e39781fc8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00009.html">basic_lostream</a>&lt;char&gt; <a class="el" href="a00009.html">pqxx::lostream</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a79c907a65843b9d4887ccbb44d5b1b"></a><!-- doxytag: member="pqxx::olostream" ref="a9a79c907a65843b9d4887ccbb44d5b1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00010.html">basic_olostream</a>&lt;char&gt; <a class="el" href="a00010.html">pqxx::olostream</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6808f9a0c8dea288c2df81b930d06c34"></a><!-- doxytag: member="pqxx::trigger" ref="a6808f9a0c8dea288c2df81b930d06c34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00063.html">notify_listener</a> <a class="el" href="a00063.html">pqxx::trigger</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a00210.html#_deprecated000010">Deprecated:</a></b></dt><dd>The trigger class from libpqxx 1.x/2.x has been replaced with <a class="el" href="a00062.html">notification_receiver</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="afb3789542d30cda25ee02ba8d2c41a46"></a><!-- doxytag: member="pqxx::tuple_difference_type" ref="afb3789542d30cda25ee02ba8d2c41a46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed int <a class="el" href="a00176.html#afb3789542d30cda25ee02ba8d2c41a46">pqxx::tuple_difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6f886167ad26ee519591f7a983ac6d9"></a><!-- doxytag: member="pqxx::tuple_size_type" ref="ac6f886167ad26ee519591f7a983ac6d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="a00176.html#ac6f886167ad26ee519591f7a983ac6d9">pqxx::tuple_size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a8f05a60f9e1f7dc4e4af5dce6b987c8c"></a><!-- doxytag: member="pqxx::isolation_level" ref="a8f05a60f9e1f7dc4e4af5dce6b987c8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00176.html#a8f05a60f9e1f7dc4e4af5dce6b987c8c">pqxx::isolation_level</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transaction isolation levels; PostgreSQL doesn't implement all SQL levels. </p>
<p>The only levels implemented in postgres are read_committed and serializable; SQL also defines read_uncommitted and repeatable_read. Unless you're bent on using nasty tricks to communicate between ongoing transactions and such, you won't really need isolation levels for anything except performance optimization. In that case, you can safely emulate read_uncommitted by using read_committed and repeatable_read by using serializable. In general, serializable is the safest choice. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8f05a60f9e1f7dc4e4af5dce6b987c8cabedeb7c33721ac28a9e35be36f214f2d"></a><!-- doxytag: member="read_committed" ref="a8f05a60f9e1f7dc4e4af5dce6b987c8cabedeb7c33721ac28a9e35be36f214f2d" args="" -->read_committed</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8f05a60f9e1f7dc4e4af5dce6b987c8ca022ad2c1a5b247f6cc5790909e708569"></a><!-- doxytag: member="serializable" ref="a8f05a60f9e1f7dc4e4af5dce6b987c8ca022ad2c1a5b247f6cc5790909e708569" args="" -->serializable</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dc4688a8f01e6679b2afa93481836cc"></a><!-- doxytag: member="pqxx::readwrite_policy" ref="a1dc4688a8f01e6679b2afa93481836cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00176.html#a1dc4688a8f01e6679b2afa93481836cc">pqxx::readwrite_policy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1dc4688a8f01e6679b2afa93481836cca4080e8f00464997c4345ddb2a15b3986"></a><!-- doxytag: member="read_only" ref="a1dc4688a8f01e6679b2afa93481836cca4080e8f00464997c4345ddb2a15b3986" args="" -->read_only</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1dc4688a8f01e6679b2afa93481836cca7fbb98c4665801b02d8cbeeb2dde0858"></a><!-- doxytag: member="read_write" ref="a1dc4688a8f01e6679b2afa93481836cca7fbb98c4665801b02d8cbeeb2dde0858" args="" -->read_write</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aac7c904372c0bffcd8c8b121f2c3f13e"></a><!-- doxytag: member="pqxx::describe_thread_safety" ref="aac7c904372c0bffcd8c8b121f2c3f13e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00101.html">pqxx::thread_safety_model</a> pqxx::describe_thread_safety </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Describe thread safety available in this build. </p>

<p>References <a class="el" href="a00101.html#adddd2eaf6dbc5feca29ce00f91b4d648">pqxx::thread_safety_model::description</a>, <a class="el" href="a00101.html#a76f2924aaefac243d3770f1f4b698211">pqxx::thread_safety_model::have_safe_strerror</a>, <a class="el" href="a00101.html#abe3528c0d2e42d6e98d80f0b45d79002">pqxx::thread_safety_model::safe_kerberos</a>, <a class="el" href="a00101.html#a3fe3fa8e530712e5228d2b5379871540">pqxx::thread_safety_model::safe_libpq</a>, <a class="el" href="a00101.html#ace2546ec39e30e8793cc4a296216f259">pqxx::thread_safety_model::safe_query_cancel</a>, and <a class="el" href="a00101.html#adb5c47ea21c35c73432de0d0b7e80bdb">pqxx::thread_safety_model::safe_result_copy</a>.</p>

</div>
</div>
<a class="anchor" id="aad07bde6f6d1012bc1fbd66e2339a213"></a><!-- doxytag: member="pqxx::encrypt_password" ref="aad07bde6f6d1012bc1fbd66e2339a213" args="(const std::string &amp;user, const std::string &amp;password)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pqxx::encrypt_password </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encrypt password for given user. Requires libpq 8.2 or better. </p>
<p>Use this when setting a new password for the user if password encryption is enabled. Inputs are the username the password is for, and the plaintext password.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>encrypted version of the password, suitable for encrypted PostgreSQL authentication.</dd></dl>
<p>Thus the password for a user can be changed with: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> setpw(transaction_base &amp;t, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp;user, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp;pw)
 {
   t.exec(<span class="stringliteral">&quot;ALTER USER &quot;</span> + user + <span class="stringliteral">&quot; &quot;</span>
        <span class="stringliteral">&quot;PASSWORD &#39;&quot;</span> + <a class="code" href="a00176.html#aad07bde6f6d1012bc1fbd66e2339a213" title="Encrypt password for given user. Requires libpq 8.2 or better.">encrypt_password</a>(user,pw) + <span class="stringliteral">&quot;&#39;&quot;</span>);
 }
</pre></div><dl class="since"><dt><b>Since:</b></dt><dd>libpq 8.2 </dd></dl>

</div>
</div>
<a class="anchor" id="ac634c894064d879d8e563175842e27be"></a><!-- doxytag: member="pqxx::field::to&lt; std::string &gt;" ref="ac634c894064d879d8e563175842e27be" args="(std::string &amp;Obj) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::field::to&lt; std::string &gt; </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specialization: <code>to(string &amp;)</code>. </p>

</div>
</div>
<a class="anchor" id="aab2b52ca97031dff1e8a6a7f654c04ea"></a><!-- doxytag: member="pqxx::from_string" ref="aab2b52ca97031dff1e8a6a7f654c04ea" args="(const field &amp;F, T &amp;Obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::from_string </td>
          <td>(</td>
          <td class="paramtype">const field &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a field's string contents to another type. </p>

<p>References <a class="el" href="a00040.html#a97781b0028cbfd2dca1106943a27afae">pqxx::field::c_str()</a>, and <a class="el" href="a00040.html#ad8d3b3ef9308b577d178086e4b295ca5">pqxx::field::size()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#gad1cc702bf191d535e40a2d5b84042e1c">from_string()</a>, <a class="el" href="a00085.html#a2aefb76b1cea234cc687735a3f8bc51a">pqxx::internal::sql_cursor::move()</a>, and <a class="el" href="a00040.html#a228477f414956aa49c7c40769f430b8d">pqxx::field::to()</a>.</p>

</div>
</div>
<a class="anchor" id="a79ecc564993aea182fe2d82ea9512e91"></a><!-- doxytag: member="pqxx::operator+" ref="a79ecc564993aea182fe2d82ea9512e91" args="(const_tuple_iterator::difference_type o, const_tuple_iterator i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00028.html">const_tuple_iterator</a> pqxx::operator+ </td>
          <td>(</td>
          <td class="paramtype">const_tuple_iterator::difference_type&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_tuple_iterator&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14f86142785f212ef3de46040e22c532"></a><!-- doxytag: member="pqxx::operator+" ref="a14f86142785f212ef3de46040e22c532" args="(result::difference_type o, const_result_iterator i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00025.html">const_result_iterator</a> pqxx::operator+ </td>
          <td>(</td>
          <td class="paramtype">result::difference_type&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_result_iterator&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af9d548cd3c597e67d8a4288ba24a17f8"></a><!-- doxytag: member="pqxx::operator+" ref="af9d548cd3c597e67d8a4288ba24a17f8" args="(result::difference_type n, const const_reverse_result_iterator &amp;i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00026.html">const_reverse_result_iterator</a> pqxx::operator+ </td>
          <td>(</td>
          <td class="paramtype">result::difference_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_reverse_result_iterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="a00026.html#af0afdb9600704e015047eefae139bd27">pqxx::const_reverse_result_iterator::base()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ce373522ba1facb44d6facb66667e5a"></a><!-- doxytag: member="pqxx::operator&lt;&lt;" ref="a8ce373522ba1facb44d6facb66667e5a" args="(std::basic_ostream&lt; CHAR &gt; &amp;S, const pqxx::field &amp;F)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CHAR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CHAR&gt;&amp; pqxx::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CHAR &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00040.html">pqxx::field</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a result field to any type of stream. </p>
<p>This can be convenient when writing a field to an output stream. More importantly, it lets you write a field to e.g. a <code>stringstream</code> which you can then use to read, format and convert the field in ways that to() does not support.</p>
<p>Example: parse a field into a variable of the nonstandard "&lt;tt&gt;long long&lt;/tt&gt;" type.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> result R;
 <span class="keywordtype">long</span> <span class="keywordtype">long</span> L;
 stringstream S;

 <span class="comment">// Write field&#39;s string into S</span>
 S &lt;&lt; R[0][0];

 <span class="comment">// Parse contents of S into L</span>
 S &gt;&gt; L;
</pre></div> 
<p>References <a class="el" href="a00040.html#a97781b0028cbfd2dca1106943a27afae">pqxx::field::c_str()</a>, and <a class="el" href="a00040.html#ad8d3b3ef9308b577d178086e4b295ca5">pqxx::field::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a99697c7c2e72286fc59e48c8af803c18"></a><!-- doxytag: member="pqxx::separated_list" ref="a99697c7c2e72286fc59e48c8af803c18" args="(const std::string &amp;sep, ITER begin, ITER end, ACCESS access)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITER , typename ACCESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string pqxx::separated_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITER&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ACCESS&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access iterators using ACCESS functor, returning separator-separated list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string (to be placed between items) </td></tr>
    <tr><td class="paramname">begin</td><td>beginning of items sequence </td></tr>
    <tr><td class="paramname">end</td><td>end of items sequence </td></tr>
    <tr><td class="paramname">access</td><td>functor defining how to dereference sequence elements </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00176.html#a35be8b6c29c0272a015f356089c1d2ed">to_string()</a>.</p>

<p>Referenced by <a class="el" href="a00099.html#ab513ec3a0610b3500dc18eced77b3d6f">pqxx::tablestream::columnlist()</a>, <a class="el" href="a00100.html#afc25db49ef4aec1d46b0cdc97304edcd">pqxx::tablewriter::generate()</a>, and <a class="el" href="a00202.html#ga76574bffb7a200dc73a88bf1be8903d8">separated_list()</a>.</p>

</div>
</div>
<a class="anchor" id="a35be8b6c29c0272a015f356089c1d2ed"></a><!-- doxytag: member="pqxx::to_string" ref="a35be8b6c29c0272a015f356089c1d2ed" args="(const field &amp;Obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string pqxx::to_string </td>
          <td>(</td>
          <td class="paramtype">const field &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a field to a string. </p>

<p>References <a class="el" href="a00040.html#a97781b0028cbfd2dca1106943a27afae">pqxx::field::c_str()</a>, and <a class="el" href="a00040.html#ad8d3b3ef9308b577d178086e4b295ca5">pqxx::field::size()</a>.</p>

<p>Referenced by <a class="el" href="a00023.html#a4963aaba6da521d480c21c7ec01835cf">pqxx::connection_base::adorn_name()</a>, <a class="el" href="a00013.html#a48d3b98f62d903bc99555d6c786d334a">pqxx::binarystring::at()</a>, <a class="el" href="a00082.html#a21afe937e085a4b3346080c389a12fb7">pqxx::result::column_name()</a>, <a class="el" href="a00082.html#a7a70138c10119663c29f81853ed21969">pqxx::result::column_table()</a>, <a class="el" href="a00082.html#a887f5867a4c241990ffb697097ddc2c9">pqxx::result::column_type()</a>, <a class="el" href="a00194.html#a92248177718d21820d8d94d9b0caecb7">pqxx::internal::EscapeAny()</a>, <a class="el" href="a00068.html#a3d89c57d7619430a3847595d8fb902bc">pqxx::pipeline::is_finished()</a>, <a class="el" href="a00203.html#ga5f6a230109a2a61c93ebfcb06b4f975b">pqxx::connection_base::quote()</a>, <a class="el" href="a00058.html#aac375f66e0a9fb817e4e59a1e73f6ba7">pqxx::largeobjectaccess::read()</a>, <a class="el" href="a00056.html#a7976bf34f68473dd51809bf25682aa03">pqxx::largeobject::remove()</a>, <a class="el" href="a00068.html#af94a53d0eecb7485cb135155f912ce8e">pqxx::pipeline::retain()</a>, <a class="el" href="a00176.html#a99697c7c2e72286fc59e48c8af803c18">separated_list()</a>, <a class="el" href="a00044.html#a255914b05d1f935922338eeebcb10144">pqxx::icursorstream::set_stride()</a>, <a class="el" href="a00194.html#a89028a8bf1f6d1e8b34f4b474745d748">pqxx::internal::sleep_seconds()</a>, <a class="el" href="a00082.html#a9c54931412fec6e7516cacff4fcdfcf3">pqxx::result::table_column()</a>, <a class="el" href="a00056.html#ad97df88e75558320c89ea4f39c35afe2">pqxx::largeobject::to_file()</a>, <a class="el" href="a00201.html#ga73d2bdd0531ce4f30db5ff11b4a8eaed">to_string()</a>, and <a class="el" href="a00058.html#ad04b47cf5b016f02e855f5e9c0bbccae">pqxx::largeobjectaccess::write()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a1abfa7aae5089dad48d69a60a9e557e3"></a><!-- doxytag: member="pqxx::oid_none" ref="a1abfa7aae5089dad48d69a60a9e557e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const oid <a class="el" href="a00176.html#a1abfa7aae5089dad48d69a60a9e557e3">pqxx::oid_none</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The "null" oid. </p>

<p>Referenced by <a class="el" href="a00082.html#a7a70138c10119663c29f81853ed21969">pqxx::result::column_table()</a>, <a class="el" href="a00082.html#a887f5867a4c241990ffb697097ddc2c9">pqxx::result::column_type()</a>, <a class="el" href="a00056.html#ae3a035076692d93ef07ab636e47fcc81">pqxx::largeobject::largeobject()</a>, and <a class="el" href="a00056.html#a70fe02eba0ce7e8d83db9bc3340260af">pqxx::largeobject::Reason()</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00176.html">pqxx</a>      </li>
      <li class="footer">Generated on Sun Nov 27 2011 18:14:13 for libpqxx by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
